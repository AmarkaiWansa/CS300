# CS300
The main problem I had to solve in the projects was learning how efficient programs run and how to code them. This involved understanding that depending on the program, there are many ways to create an algorithm, such as hash tables or binary search trees, each with its own strengths and weaknesses. For instance, hash tables are excellent for quick data retrieval, while binary search trees are efficient for sorted data operations. Recognizing these differences was crucial in selecting the right data structure for the task at hand.

I approached the problem by first understanding what the program needed to do: it needed to create a list of courses, sort them, and display any prerequisites. Given these requirements, I chose to implement a binary search tree because I believed it to be the quickest method for sorting. Binary search trees offer efficient searching, insertion, and deletion operations, which seemed ideal for managing the course list. However, I acknowledged that other methods, such as hash tables or linked lists, could have worked as well, especially since the list of courses was relatively small and the performance differences might not be significant in such cases.

Throughout the project, I encountered several roadblocks, the most significant being issues with reading files. Initially, I tried using a CSV parser, which was the method taught in the course. However, I faced numerous challenges with this approach, such as handling different file formats and ensuring data integrity. To overcome these obstacles, I turned to Google and Stack Overflow, where I found a wealth of information and solutions shared by the programming community. After extensive searching and experimenting, I found a reliable method for reading files that suited my needs better than the CSV parser.

Working on this project expanded my approach to designing software and developing programs. It made me realize that there are many different ways to create programs, with some being better options than others depending on the specific requirements. This understanding is crucial because knowing exactly what the program needs to do allows for the creation of algorithms that work well with it, ensuring efficiency and effectiveness. Otherwise, the code may be slower and less efficient than desired, leading to performance issues.

Moreover, my work on this project has evolved the way I write programs that are maintainable, readable, and adaptable. I have always tried to organize my code in a visually appealing way, ensuring that it is easy to read and maintain. This project reinforced the importance of these practices, as well-organized code is easier to debug and extend. Additionally, I have increased my adaptability by learning more ways to create algorithms that can be applied to different programs. This newfound adaptability means that I can now approach future projects with a broader toolkit of techniques and solutions, allowing me to tailor my approach to the specific needs of each project.

Overall, my experiences with these projects have significantly contributed to my growth as a programmer. They have taught me valuable lessons about efficiency, problem-solving, and the importance of selecting the right tools and methods for the job. As I continue to explore and experiment with different techniques, I am confident that these skills will serve me well in future endeavors
